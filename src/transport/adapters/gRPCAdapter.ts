import * as grpc from '@grpc/grpc-js';import * as protoLoader from '@grpc/proto-loader';import { Transport } from '../Transport';import { NodeId, Message } from '../../types';import { EventEmitter } from 'events';interface GossipMessage {  nodeId: string;  data: Buffer;  timestamp: number;  messageType: string;}interface NodeConnection {  client: any;  stream?: any;  lastActivity: number;  isHealthy: boolean;}/** * Enhanced gRPC transport adapter with streaming support, connection pooling, * and health checking for high-performance cluster communication */export class gRPCAdapter extends Transport {  private nodeId: NodeId;  private server: grpc.Server;  private clients = new Map<string, NodeConnection>();  private streams = new Map<string, any>();  private serviceDefinition: any;  private isStarted = false;  private healthCheckInterval?: NodeJS.Timeout;  private connectionPool = new Map<string, NodeConnection[]>();    private readonly port: number;  private readonly maxConnections: number;  private readonly healthCheckIntervalMs: number;  private readonly connectionTimeout: number;  constructor(    nodeId: NodeId,     port: number = 50051,    options: {      maxConnections?: number;      healthCheckInterval?: number;      connectionTimeout?: number;    } = {}  ) {    super();    this.nodeId = nodeId;    this.port = port;    this.maxConnections = options.maxConnections || 10;    this.healthCheckIntervalMs = options.healthCheckInterval || 30000;    this.connectionTimeout = options.connectionTimeout || 10000;        this.server = new grpc.Server();    this.loadProtoDefinition();  }  /**   * Load protocol buffer definitions   */  private loadProtoDefinition(): void {    // Create a simple proto definition for gossip protocol    const protoDefinition = `      syntax = "proto3";            package gossip;            service GossipService {        rpc SendMessage(GossipRequest) returns (GossipResponse);        rpc StreamMessages(stream GossipRequest) returns (stream GossipResponse);        rpc HealthCheck(HealthRequest) returns (HealthResponse);      }            message GossipRequest {        string node_id = 1;        bytes data = 2;        int64 timestamp = 3;        string message_type = 4;        map<string, string> metadata = 5;      }            message GossipResponse {        bool success = 1;        string error = 2;        int64 timestamp = 3;      }            message HealthRequest {        string node_id = 1;      }            message HealthResponse {        bool healthy = 1;        string status = 2;        int64 timestamp = 3;      }    `;    try {      // In a real implementation, we'd load from a .proto file      // For now, we'll use a simplified approach      this.serviceDefinition = {        GossipService: {          SendMessage: {            path: '/gossip.GossipService/SendMessage',            requestStream: false,            responseStream: false,            requestType: 'GossipRequest',            responseType: 'GossipResponse'          },          StreamMessages: {            path: '/gossip.GossipService/StreamMessages',            requestStream: true,            responseStream: true,            requestType: 'GossipRequest',            responseType: 'GossipResponse'          },          HealthCheck: {            path: '/gossip.GossipService/HealthCheck',            requestStream: false,            responseStream: false,            requestType: 'HealthRequest',            responseType: 'HealthResponse'          }        }      };    } catch (error) {      console.error('Failed to load proto definition:', error);      throw error;    }  }  async start(): Promise<void> {    if (this.isStarted) return;    try {      // Add service implementation      this.server.addService(this.serviceDefinition.GossipService, {        SendMessage: this.handleSendMessage.bind(this),        StreamMessages: this.handleStreamMessages.bind(this),        HealthCheck: this.handleHealthCheck.bind(this)      });      // Start server      await new Promise<void>((resolve, reject) => {        this.server.bindAsync(          `0.0.0.0:${this.port}`,          grpc.ServerCredentials.createInsecure(),          (error, port) => {            if (error) {              reject(error);            } else {              this.server.start();              resolve();            }          }        );      });      this.isStarted = true;      this.startHealthCheck();      this.emit('started', { port: this.port });          } catch (error) {      this.emit('error', error);      throw error;    }  }  async stop(): Promise<void> {    if (!this.isStarted) return;    // Stop health checking    if (this.healthCheckInterval) {      clearInterval(this.healthCheckInterval);      this.healthCheckInterval = undefined;    }    // Close all streams    for (const [id, stream] of this.streams) {      try {        if (stream && typeof stream.end === 'function') {          stream.end();        }      } catch (error) {        console.error(`Error closing stream ${id}:`, error);      }    }    this.streams.clear();    // Close all clients    for (const [id, connection] of this.clients) {      try {        if (connection.client && typeof connection.client.close === 'function') {          connection.client.close();        }      } catch (error) {        console.error(`Error closing client ${id}:`, error);      }    }    this.clients.clear();    // Stop server    if (this.server) {      await new Promise<void>((resolve) => {        this.server.tryShutdown((error) => {          if (error) {            console.error('Error during graceful shutdown:', error);            this.server.forceShutdown();          }          resolve();        });      });    }    this.isStarted = false;    this.emit('stopped');  }  async send(message: Message, target: NodeId): Promise<void> {    if (!this.isStarted) {      throw new Error('gRPC adapter not started');    }    const connection = await this.getOrCreateConnection(target.id);        const request = {      node_id: this.nodeId.id,      data: Buffer.from(JSON.stringify(message)),      timestamp: Date.now(),      message_type: message.type || 'gossip',      metadata: message.metadata || {}    };    return new Promise((resolve, reject) => {      const deadline = Date.now() + this.connectionTimeout;            connection.client.SendMessage(request, { deadline }, (error: any, response: any) => {        if (error) {          this.handleConnectionError(target.id, error);          reject(error);        } else if (response.success) {          connection.lastActivity = Date.now();          this.emit('message-sent', { targetNodeId: target.id, message });          resolve();        } else {          reject(new Error(response.error || 'Unknown gRPC error'));        }      });    });  }  async broadcast(message: Message, targetNodes?: string[]): Promise<void> {    const targets = targetNodes || Array.from(this.clients.keys());    const promises = targets.map(nodeId =>       this.send(message, { id: nodeId } as NodeId).catch(error => {        console.error(`Failed to send to ${nodeId}:`, error);        return error;      })    );    const results = await Promise.allSettled(promises);    const failures = results.filter(r => r.status === 'rejected').length;        this.emit('broadcast-complete', {       totalTargets: targets.length,       failures,      successRate: (targets.length - failures) / targets.length    });  }  /**   * Get or create connection to target node   */  private async getOrCreateConnection(targetNodeId: string): Promise<NodeConnection> {    // Check existing connection    let connection = this.clients.get(targetNodeId);        if (connection && connection.isHealthy) {      return connection;    }    // Create new connection    const client = new grpc.Client(      `${targetNodeId}:${this.port}`, // Assumes nodes use same port      grpc.credentials.createInsecure(),      {        'grpc.keepalive_time_ms': 30000,        'grpc.keepalive_timeout_ms': 5000,        'grpc.keepalive_permit_without_calls': true,        'grpc.http2.max_pings_without_data': 0,        'grpc.http2.min_time_between_pings_ms': 10000,        'grpc.http2.min_ping_interval_without_data_ms': 300000      }    );    connection = {      client,      lastActivity: Date.now(),      isHealthy: true    };    this.clients.set(targetNodeId, connection);    this.emit('connection-established', { targetNodeId });    return connection;  }  /**   * Handle incoming SendMessage calls   */  private handleSendMessage(call: any, callback: any): void {    try {      const request = call.request;      const message = JSON.parse(request.data.toString());            this.emit('message-received', {        fromNodeId: request.node_id,        message,        timestamp: request.timestamp      });      callback(null, {        success: true,        timestamp: Date.now()      });    } catch (error) {      callback(null, {        success: false,        error: error instanceof Error ? error.message : 'Unknown error',        timestamp: Date.now()      });    }  }  /**   * Handle incoming StreamMessages calls   */  private handleStreamMessages(call: any): void {    const streamId = `stream-${Date.now()}-${Math.random()}`;    this.streams.set(streamId, call);    call.on('data', (request: any) => {      try {        const message = JSON.parse(request.data.toString());                this.emit('stream-message-received', {          streamId,          fromNodeId: request.node_id,          message,          timestamp: request.timestamp        });        // Echo response        call.write({          success: true,          timestamp: Date.now()        });      } catch (error) {        call.write({          success: false,          error: error instanceof Error ? error.message : 'Unknown error',          timestamp: Date.now()        });      }    });    call.on('end', () => {      this.streams.delete(streamId);      this.emit('stream-ended', { streamId });    });    call.on('error', (error: any) => {      this.streams.delete(streamId);      this.emit('stream-error', { streamId, error });    });  }  /**   * Handle health check requests   */  private handleHealthCheck(call: any, callback: any): void {    callback(null, {      healthy: this.isStarted,      status: this.isStarted ? 'healthy' : 'stopped',      timestamp: Date.now()    });  }  /**   * Start health checking of connections   */  private startHealthCheck(): void {    this.healthCheckInterval = setInterval(async () => {      await this.performHealthCheck();    }, this.healthCheckIntervalMs);    this.healthCheckInterval.unref();  }  /**   * Perform health check on all connections   */  private async performHealthCheck(): Promise<void> {    const healthPromises: Promise<void>[] = [];    for (const [nodeId, connection] of this.clients) {      healthPromises.push(this.checkConnectionHealth(nodeId, connection));    }    await Promise.allSettled(healthPromises);  }  /**   * Check health of individual connection   */  private async checkConnectionHealth(nodeId: string, connection: NodeConnection): Promise<void> {    try {      const request = { node_id: this.nodeId.id };      const deadline = Date.now() + 5000; // 5 second timeout      await new Promise((resolve, reject) => {        connection.client.HealthCheck(request, { deadline }, (error: any, response: any) => {          if (error || !response.healthy) {            reject(error || new Error('Node unhealthy'));          } else {            resolve(response);          }        });      });      connection.isHealthy = true;      connection.lastActivity = Date.now();    } catch (error) {      this.handleConnectionError(nodeId, error);    }  }  /**   * Handle connection errors   */  private handleConnectionError(nodeId: string, error: any): void {    const connection = this.clients.get(nodeId);    if (connection) {      connection.isHealthy = false;      this.emit('connection-error', { nodeId, error });            // Remove unhealthy connection after some time      setTimeout(() => {        if (connection && !connection.isHealthy) {          this.clients.delete(nodeId);          this.emit('connection-removed', { nodeId });        }      }, 30000); // 30 seconds    }  }  /**   * Get adapter statistics   */  getStats(): {    activeConnections: number;    activeStreams: number;    healthyConnections: number;    serverPort: number;    isStarted: boolean;  } {    const healthyConnections = Array.from(this.clients.values())      .filter(conn => conn.isHealthy).length;    return {      activeConnections: this.clients.size,      activeStreams: this.streams.size,      healthyConnections,      serverPort: this.port,      isStarted: this.isStarted    };  }  /**   * Get connection status   */  getConnectionStatus(nodeId: string): {    connected: boolean;    healthy: boolean;    lastActivity?: number;  } {    const connection = this.clients.get(nodeId);        if (!connection) {      return { connected: false, healthy: false };    }    return {      connected: true,      healthy: connection.isHealthy,      lastActivity: connection.lastActivity    };  }}